__Preparing for Pratice__
- There are two dataset used - legislators and legislator_term
- The solutions, questions and content in this file are mainly referenced from the book "SQL for Data Analysis Advanced Techniques for Transforming Data into Insight"
- The syntax in this file is mainly written in SQL Server format.

------------------------------------------------------------------------------------------------------------
## 1. COHORTS - A USEFUL ANALYSIS FRAMEWORK
* __Cohort__
  * A group of individuals who share some characteristic of interest
  * Important to consider the ethical implications of cohorting entities without their awareness

* __Cohort Analysis__
  * Framework for detecting correlations between cohort characteristics and these long-term trends => lead to hypotheses about the causal driver.
  * Monitor new cohorts of users or customers and assess how they compare to previous cohorts
  * Three components - Corhort grouping, Time series, and Aggregate metric
  * Four types - Retention, Survivorship, Returnship (repeating purchase behavior), and Cumulative behavior

### 1.1. Components of Cohort Analysis
* __Cohort Grouping__ // Cohort Definition
  - based on a starting date.
  - formed around characteristics that are innate or changing over time.
  - 
* __Time Series__
 
* __Aggregate Metric__

### 1.2. Types of Cohort Analysis


------------------------------------------------------------------------------------------------------------
## 2. RETENTION

### 2.1. Basic Retention Curve
Calculate the percentage of cohort retained in the whole population
* __Self JOIN__
```
SELECT	DATEDIFF(year, a.first_term, b.term_start) AS period,
	a.id_bioguide, a.first_term, b.term_start
FROM	(
	SELECT	id_bioguide, MIN(term_start) AS first_term
	FROM	legislator_terms
	GROUP BY	id_bioguide
	)	a
	INNER JOIN legislator_terms b ON a.id_bioguide = b.id_bioguide
WHERE	a.id_bioguide = 'T000275'
-- GROUP BY	DATEDIFF(year, a.first_term, b.term_start);
ORDER BY	 period ASC, id_bioguide ASC;
```
=> find how long a legislator retain calculating from the first term which is minimum of term_start.
```
SELECT	period,
		FIRST_VALUE(cohort_retained) OVER (ORDER BY period) AS cohort_size,
		cohort_retained,
		cohort_retained*1.0/ FIRST_VALUE(cohort_retained) OVER (ORDER BY period)	AS pct_retained
FROM	(
		SELECT	DATEDIFF(year, a.first_term, FORMAT(b.term_start, 'yyyy-01-01')) AS period,
				COUNT(DISTINCT a.id_bioguide) AS cohort_retained
		FROM	(
				SELECT	id_bioguide, FORMAT(MIN(term_start), 'yyyy-01-01') AS first_term
				FROM	legislator_terms
				GROUP BY	id_bioguide
				)	a
				INNER JOIN legislator_terms b ON a.id_bioguide = b.id_bioguide
		GROUP BY	DATEDIFF(year, a.first_term, FORMAT(b.term_start, 'yyyy-01-01'))
		) aa
ORDER BY 1;
```
* __Pivoting__ => `CASE WHEN`
```
SELECT	cohort_size,
	MAX(CASE WHEN period = 0 THEN pct_retained END) AS yr0,
	MAX(CASE WHEN period = 1 THEN pct_retained END) AS yr1,
	MAX(CASE WHEN period = 2 THEN pct_retained END) AS yr2,
	MAX(CASE WHEN period = 3 THEN pct_retained END) AS yr3,
	MAX(CASE WHEN period = 4 THEN pct_retained END) AS yr4
FROM	(
	SELECT	period,
		FIRST_VALUE(cohort_retained) OVER (ORDER BY period) AS cohort_size,
		cohort_retained,
		cohort_retained*1.0/FIRST_VALUE(cohort_retained) OVER (ORDER BY period) AS pct_retained
	FROM	(
		SELECT	DATEDIFF(year, a.first_term, b.term_start) AS period,
			COUNT(DISTINCT a.id_bioguide) AS cohort_retained
		FROM	(
			SELECT	id_bioguide, MIN(term_start) AS first_term
			FROM	legislator_terms
			GROUP BY	id_bioguide
			) a 
			INNER JOIN	legislator_terms b ON a.id_bioguide = b.id_bioguide
			GROUP BY	DATEDIFF(year, a.first_term, b.term_start)
			) aa
	) aaa
GROUP BY	cohort_size;
```

### 2.2. Adjusting Time Series to Increase Retention Accuracy
- The first step is to create a data set that contains a record for each Dec 31th that each legislator was in the office.
```
SELECT	a.id_bioguide, a.first_term, 
	b.term_start, b.term_end,
	c.date,
	DATEDIFF(year, a.first_term, c.date) AS period
FROM	(
	SELECT	id_bioguide, MIN(term_start) AS first_term
	FROM	legislator_terms
	GROUP BY id_bioguide
	) a
	INNER JOIN	legislator_terms b	ON a.id_bioguide = b.id_bioguide
	LEFT JOIN	date_dim c		ON c.date	BETWEEN	b.term_start AND b.term_end
								AND c.month_name = 'December' AND c.day_of_month = 31
;
```
=> within a particular year, those legislators who are retained would be counted, and in the next year, it would be re-calculated.

- The second is to calculate the cohort_retained for each period
```
SELECT	period,
	COUNT(DISTINCT id_bioguide) AS cohort_retained
FROM	(
	SELECT	a.id_bioguide, a.first_term, 
		b.term_start, b.term_end,
		c.date,
		COALESCE(DATEDIFF(year, a.first_term, c.date), 0)  AS period
		FROM	(
			SELECT	id_bioguide, MIN(term_start) AS first_term
			FROM	legislator_terms
			GROUP BY id_bioguide
			) a
			INNER JOIN	legislator_terms b	ON a.id_bioguide = b.id_bioguide
			LEFT JOIN	date_dim c		ON c.date	BETWEEN	b.term_start AND b.term_end
										AND c.month_name = 'December' AND c.day_of_month = 31
	) aa
GROUP BY	period
ORDER BY	1;
```
=> For those whose terms are ended up under a year (date and period columns have null), it is calculated as 0 (`COALESCE(column_name, 0)`).

- The final step is to calculate the cohort_size and pct_retained.
```
SELECT	period, 
	FIRST_VALUE(cohort_retained) OVER (ORDER BY period) AS cohort_size,
	cohort_retained,
	cohort_retained*1.0/ FIRST_VALUE(cohort_retained) OVER (ORDER BY period) AS pct_retained
FROM	(
	SELECT	COUNT(DISTINCT a.id_bioguide) AS cohort_retained,
		COALESCE(DATEDIFF(year, a.first_term, c.date), 0)  AS period
	FROM	(
		SELECT	id_bioguide, MIN(term_start) AS first_term
		FROM	legislator_terms
		GROUP BY id_bioguide
		) a
		INNER JOIN	legislator_terms b	ON a.id_bioguide = b.id_bioguide
		LEFT JOIN	date_dim c		ON c.date	BETWEEN	b.term_start AND b.term_end
									AND c.month_name = 'December' AND c.day_of_month = 31
		GROUP BY	COALESCE(DATEDIFF(year, a.first_term, c.date), 0)
	) aa;
```
__Note__: Multiplying a value by `1.0` is commonly used to convert the value to a decimal or floating-point number.

If the dataset does not contain an end date, there are some options for imputing one.
- Add a fixed interval to the start date
```
SELECT	a.id_bioguide, a.first_term,
	b.term_start,
	CASE
		WHEN b.term_type = 'rep' THEN DATEADD(YEAR, 2, b.term_start)
		WHEN b.term_type = 'sen' THEN DATEADD(YEAR, 6, B.term_start) 
	END AS term_end
FROM	(
	SELECT	id_bioguide,
		MIN(term_start) AS first_term
	FROM	legislator_terms
	GROUP BY	id_bioguide
	) a
	INNER JOIN legislator_terms b ON a.id_bioguide = b.id_bioguide;
```
___=> The drawback of this code block is that it fails to capture instances in whcih a legislator did not complete a full term___

- Use subsequent satarting date, minus one day, as the term_end date => Windoe Function `LEAD()`
```
SELECT	a.id_bioguide, a.first_term, b.term_start,
	DATEADD(DAY, -1, LEAD(b.term_start) OVER (PARTITION BY a.id_bioguide ORDER BY b.term_start)) AS term_end
FROM	(
	SELECT	id_bioguide,
		MIN(term_start) AS first_term
	FROM	legislator_terms
	GROUP BY	id_bioguide
	) a
	INNER JOIN legislator_terms b ON a.id_bioguide = b.id_bioguide;
```
__Note: `LEAD()` window function is used to take the date of starting the next term (1 row below; column term_start) and then the obtained value will be subtracted by 1.

